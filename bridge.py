from itertools import chain
import os
from pathlib import Path
import shutil
from subprocess import run, PIPE
import tempfile

import click
import h5py
from jinja2 import Template
import lrspline as lr
import numpy as np
import quadpy
from scipy.sparse import csc_matrix
import splipy.surface_factory as sf
from splipy.io import G2
from tqdm import tqdm

from typing import Union, Iterable, Optional, List, Tuple, Union


IFEM = '/home/eivind/repos/IFEM/Apps/Elasticity/Linear/build/bin/LinEl'
INPUT = [
    'topology.xinp',
    'topologysets.xinp',
]
OUTPUT = [
    'bridge.xinp',
    'topology.xinp',
    'topologysets.xinp',
    'bridge.hdf5',
    'sol.out',
    'lhs.out',
    'rhs.out',
]


Solution = List[Tuple[lr.LRSplineObject, lr.LRSplineObject]]


def nel(span, meshwidth):
    return int(max(1, np.ceil(span / meshwidth)))

def read_lr(data):
    if data.startswith(b'# LRSPLINE SURFACE'):
        return lr.LRSplineSurface(data)
    return lr.LRSplineVolume(data)

def move_meshlines(source, target):
    if isinstance(source, lr.LRSplineSurface):
        for meshline in source.meshlines:
            target.insert(meshline)
    else:
        for meshrect in source.meshrects:
            target.insert(meshrect)
    target.generate_ids()

def affine(points, left, right):
    return left + (points + 1) / 2 * (right - left)

def dictzip(**kwargs):
    for values in zip(*kwargs.values()):
        yield dict(zip(kwargs.keys(), values))


class BridgeCase:

    # Discretization
    order: int
    ndim: int
    meshwidth: float
    npatches: int

    # Geometry
    span: float
    diameter: float

    # Parameters
    load: float = 0.0
    load_left: float = 0.0
    load_right: float = 10.0
    load_width: float = 0.5

    maxstep: int = 10
    beta: int = 5

    with_dirichlet: bool = True
    with_neumann: bool = True

    def __init__(self, **kwargs):
        self.__dict__.update(**kwargs)

    def directory(self, name: str, index: Union[int, str]) -> Path:
        if isinstance(index, int):
            index = f'{index:03}'
        path = Path('data') / name / index
        path.mkdir(mode=0o775, exist_ok=True, parents=True)
        return path

    def load_solution(self, index: int, step: Optional[int] = None) -> Solution:
        retval = []
        path = self.directory('raw', index)
        with h5py.File(path / 'bridge.hdf5', 'r') as f:
            step = len(f) - 1 if step is None else step
            group = f[f'{step}/Elasticity-1']
            npatches = len(group['basis'])

            for patchid in range(1, npatches + 1):
                geompatch = read_lr(group[f'basis/{patchid}'][:].tobytes())
                coeffs = group[f'fields/displacement/{patchid}'][:]
                solpatch = geompatch.clone()
                solpatch.controlpoints = coeffs.reshape(len(solpatch), -1)
                retval.append((geompatch, solpatch))
        return retval

    def setup(self):
        patchspan = self.span / self.npatches
        nel_length = nel(patchspan, self.meshwidth)
        nel_diam = nel(self.diameter, self.meshwidth)

        patch = sf.square() * (patchspan, self.diameter)
        patch.raise_order(self.order - 2, self.order - 2)
        patch.refine(nel_length - 1, nel_diam - 1)
        patches = [patch + (i * patchspan, 0) for i in range(self.npatches)]

        with G2('geometry.g2') as f:
            f.write(patches)

        with open('topology.xinp', 'w') as f:
            f.write("<?xml version='1.0' encoding='utf-8' standalone='no'?>\n")
            f.write('<!-- this file is autogenerated -->\n')
            f.write('<topology>\n')
            for i in range(1, self.npatches):
                f.write(f'  <connection master="{i}" slave="{i+1}" midx="2" sidx="1" orient="0" />\n')
            f.write('</topology>\n')

        with open('topologysets.xinp', 'w') as f:
            f.write("<?xml version='1.0' encoding='utf-8' standalone='no'?>\n")
            f.write('<!-- this file is autogenerated -->\n')
            f.write('<topologysets>\n')
            f.write('  <set name="support" type="edge">\n')
            f.write('    <item patch="1">1</item>\n')
            f.write(f'    <item patch="{self.npatches}">2</item>\n')
            f.write('  </set>\n')
            f.write('  <set name="surface" type="edge">\n')
            for i in range(1, self.npatches + 1):
                f.write(f'    <item patch="{i}">4</item>\n')
            f.write('  </set>\n')
            f.write('</topologysets>\n')

    def run_ifem(self, target: Path, context: dict, geometry: Optional[Union[str, Path]] = None, allow_fail: bool = False):
        if geometry is None:
            geometry = 'geometry.g2'

        context = context.copy()
        context['geometry'] = Path(geometry).name

        with open('bridge.xinp', 'r') as f:
            template = Template(f.read())
        with tempfile.TemporaryDirectory() as tempdir_path:
            root = Path(tempdir_path)
            with open(root / 'bridge.xinp', 'w') as f:
                f.write(template.render(**context))
            for fn in INPUT + [geometry]:
                shutil.copy(fn, root)

            result = run([IFEM, 'bridge.xinp', '-2D', '-hdf5', '-adap', '-cgl2'], cwd=root, stdout=PIPE, stderr=PIPE)
            for fn in OUTPUT + [context['geometry']]:
                if (root / fn).exists():
                    shutil.copy(root / fn, target)

        if allow_fail:
            return
        try:
            result.check_returncode()
        except:
            print(result.stderr.decode())
            raise

    def run_single(self, index: int, **kwargs):
        context = self.__class__.__dict__.copy()
        context.update(self.__dict__)
        context.update(kwargs)
        self.run_ifem(self.directory('raw', index), context)

    def run(self, nsols: int, **kwargs):
        quadrule = quadpy.line_segment.gauss_legendre(nsols)
        params = {
            'load_left': affine(quadrule.points, 0.0, self.span - self.load_width),
            'load_right': affine(quadrule.points, self.load_width, self.span),
        }

        for i, params in tqdm(enumerate(dictzip(**params)), 'Solving', total=nsols):
            self.run_single(i, **kwargs, **params)

    def merge(self, nsols: int):
        solutions = [self.load_solution(i) for i in range(nsols)]
        rootpatches = [g.clone() for g, _ in solutions[0]]

        for sol in tqdm(solutions, 'Merging'):
            for tgt, (src, _) in zip(rootpatches, sol):
                move_meshlines(src, tgt)

        for sol in tqdm(solutions, 'Back-merging'):
            for src, (tgt1, tgt2) in zip(rootpatches, sol):
                move_meshlines(src, tgt1)
                move_meshlines(src, tgt2)

        for sol in solutions:
            for root, (g, _) in zip(rootpatches, sol):
                np.testing.assert_allclose(root.controlpoints, g.controlpoints)

        path = self.directory('merged', 'geometry')
        with open(path / 'geometry.lr', 'wb') as f:
            for root in rootpatches:
                root.write(f)

        # Generate numbering as side effect
        self.fullscale()

        numbering, ndofs = self.load_numbering()
        data = np.zeros((ndofs, self.ndim))
        for i, sol in enumerate(solutions):
            for n, (_, s) in zip(numbering, sol):
                data[n,:] = s.controlpoints
            np.save(self.directory('merged', i) / 'sol.npy', data.flatten())

    def fullscale(self):
        geometry = self.directory('merged', 'geometry') / 'geometry.lr'
        target = self.directory('merged', 'fullscale')
        context = {
            'with_dirichlet': False,
            'with_neumann': False,
            'maxstep': 0,
        }
        self.run_ifem(target, context, geometry, allow_fail=True)

    def load_superlu(self, directory: Path):
        with open(directory / 'lhs.out') as f:
            next(f)
            m, n, nnz = map(int, next(f).split())
            data = np.array(list(map(float, next(f).split())), dtype=float)
            n_indptr = int(next(f))
            indptr = np.array(list(map(int, next(f).split())), dtype=int)
            n_indices = int(next(f))
            indices = np.array(list(map(int, next(f).split())), dtype=int)

        assert len(indptr) == n_indptr == m+1 == n+1
        assert nnz == n_indices == len(indices)
        return csc_matrix((data, indices, indptr), shape=(m, n))

    def load_vector(self, directory: Path, filename: str):
        with open(directory / filename) as f:
            next(f)
            return np.array(list(chain.from_iterable(map(float, l.split()) for l in f)))

    def load_sol(self, directory: Path):
        return self.load_vector(directory, 'sol.out')

    def load_rhs(self, directory: Path):
        return self.load_vector(directory, 'rhs.out')

    def load_numbering(self):
        with h5py.File(self.directory('merged', 'fullscale') / 'bridge.hdf5', 'r') as f:
            group = f['0/Elasticity-1/l2g-node']
            numbering = [group[f'{i+1}'][:] for i in range(len(group))]
        ndofs = max(map(np.max, numbering)) + 1
        return numbering, ndofs

    def load_fullscale_geometry(self):
        with open(self.directory('merged', 'geometry') / 'geometry.lr') as f:
            return lr.LRSplineObject.read_many(f)

    def verify_numbering(self):
        patches = self.load_fullscale_geometry()
        numbering, _ = self.load_numbering()
        nodes = dict()

        assert len(patches) == len(numbering) == self.npatches
        for patch, numbers in zip(patches, numbering):
            controlpoints = patch.controlpoints
            assert len(numbers) == len(controlpoints)
            for node, number in zip(controlpoints, numbers):
                assert np.linalg.norm(nodes.setdefault(number, node) - node) < 1e-10


@click.command()
@click.option('--order', '-o', default=2)
@click.option('--ndim', '-n', default=2)
@click.option('--meshwidth', '-h', default=1.0)
@click.option('--npatches', '-p', default=1)
@click.option('--span', '-s', default=10.0)
@click.option('--diameter', '-d', default=1.0)
@click.option('--load', '-l', default=1e6)
@click.option('--maxstep', default=10)
@click.option('--beta', default=5)
def main(**kwargs):
    case = BridgeCase(**kwargs)
    case.setup()

    # case.run(1, with_neumann=False, maxstep=0)
    # case.merge(1)

    case.run(10)
    case.merge(10)
    case.verify_numbering()

    # case.fullscale()
    # case.verify_numbering()
    # numbering = case.load_numbering()

    # for i in range(1):
    #     path = case.directory('raw', i)
    #     mx = case.load_superlu(path)
    #     sol = case.load_sol(path)
    #     rhs = case.load_rhs(path)
    #     print(np.mean(np.abs(mx * sol - rhs)))


if __name__ == '__main__':
    main()
